# HandwrittenDigit
C++ class for parsing bitmaps and MNIST data files for easy artificial neural network consumption.

### Disclaimer
This is not production-worthy code! View this simply as a proof-of-concept. Preconditions are implicit. No error checking exists.

### Initialization
```C++
HandwrittenDigit(char * imageBitmapFile);
HandwrittenDigit(unsigned char * pixelsValue);
HandwrittenDigit(NeuralInput pixelsPercentage);
```
A `HandwrittenDigit` can be initialized three different ways;

 1. With a filename to a bitmap.
 2. With a pointer to unsigned characters holding a value from 0 to 255 representing greyscale.
 3. With a `NeuralInput` holding a value from 0 to 1 representing greyscale.

The first constructor will open a bitmap and strip the headers converting the pixel data to a `NeuralInput` of greyscale percentages, the second constructor will convert the values from 0 to 255 to a value from 0 to 1 into a `NeuralInput`, and the last will simply copy the `NeuralInput` into the structure.

### Save
```C++
void Save(char * filename);
```
The `NeuralInput` representation of the pixels will be saved as a bitmap.

### Open
```C++
void Open(char * filename);
```
The `NeuralInput` representation of the pixels will be generated from a bitmap file.

### Getters
```C++
NeuralInput GetPixelsPercentage();
unsigned char * GetPixelsValue();
```
The pixel data generated by the class can be accessed using these methods. There are two types of output: a `NeuralInput`, which is easy to use by the `NeuralNetwork` and `HandwrittenDigitRecognizer` classes, and an unsigned character pointer, which may be easier to use in other circumstances. If this latter method is used, the output must be freed by calling the standard `free` function.

### Example
```C++
#include "HandwrittenDigit.h"
#include <sstream>

using namespace std;

char * ReadDigits(string digitsRawFileDirectory)
{
	ifstream digitsFile(digitsRawFileDirectory, ios::binary);

	int header[4];
	digitsFile.read((char *)header, sizeof(unsigned int) * 4);
	
	char * digits = (char *)malloc(header[1] /*Number of images*/ * 28 /*Pixel width*/ * 28 /*Pixel height*/);
	digitsFile.read(digits, header[1] /*Number of images*/ * 28 /*Pixel width*/ * 28 /*Pixel height*/);

	return digits;
}
char * ReadLabels(string labelsRawFileDirectory)
{

	ifstream labelsFile(labelsRawFileDirectory, ios::binary);

	int header[2];
	labelsFile.read((char *)header, sizeof(unsigned int) * 2);
	
	char * labels = (char *)malloc(header[1] /*Number of images*/);
	labelsFile.read(labels, header[1] /*Number of images*/);

	return labels;
}

int main()
{
	char * trainingDigits = ReadDigits("train-images-idx3-ubyte");
	char * trainingLabels = ReadLabels("train-labels-idx1-ubyte"); 
	char * testDigits = ReadDigits("t10k-images-idx3-ubyte"); 
	char * testLabels = ReadLabels("t10k-labels-idx1-ubyte");


	for (int i = 0; i < 60000 /*Number of training digits*/; i++)
	{
		HandwrittenDigit trainingDigit((unsigned char *)&trainingDigits[i * 784]);

		stringstream filename;

		filename << "TrainingDigit" << i + 1 << "-" << (int)trainingLabels[i] << ".bmp";

		trainingDigit.Save((char *)filename.str().c_str());
	}

	for (int i = 0; i < 10000 /*Number of test digits*/; i++)
	{
		HandwrittenDigit testDigit((unsigned char *)&testDigits[i * 784]);

		stringstream filename;

		filename << "TestDigit" << i + 1 << "-" << (int)testLabels[i] << ".bmp";

		testDigit.Save((char *)filename.str().c_str());
	}

	free(trainingDigits);
	free(trainingLabels);
	free(testDigits);
	free(testLabels);
}
```
This example uses the `HandwrittenDigit` class to read the data enclosed in the raw MNIST files. Once this data is read, the images are saved individually as bitmaps. For your convenience, these raw MNIST data files are included.
